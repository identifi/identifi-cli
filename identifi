#!/usr/bin/env node
'use strict';
var packageJson = require('./package.json');
var identifi = require('commander');
var identifi_lib = require('identifi-lib');
var colors = require('colors');
var api = identifi_lib.client
var message = identifi_lib.message

identifi
  .version(packageJson.version)
  .usage('<identifier> [options]')
  .option('-t, --type <type>', 'Force set the identifier type')
  .option('-g, --get [type]', 'Get a connected identifier of the given type')
  .option('-r, --received', 'Get messages received by the identity')
  .option('-s, --sent', 'Get messages sent by the identity')
  .option('--rate <rating>', 'Give a rating between -10 and 10 to the identity')
  // .option('--name [name]', 'Name an identity') reserved word by commander
  .option('--connect [identifier]', 'Connect an identifier to the identity')
  .option('--disconnect [identifier]', 'Disconnect an identifier from the identity')
  .option('-m --message [message]', 'Include a comment with a rating / connection')
  .option('--trustpath', 'Get a trust path to the identity')
  .option('--status', 'Get node status')
  .option('--me', 'Overview of your own identity')
  .option('--whoami', 'Overview of your own identity')
  .option('-vt, --viewpoint-type [type]', 'Set trust viewpoint type')
  .option('-vv, --viewpoint-value [value]', 'Set trust viewpoint value')
  .option('-d, --max-distance [distance]', 'Maximum trust distance from viewpoint')
  .option('-l, --limit [limit]', 'Limit the amount of results')
  .option('-o, --offset [offset]', 'Offset of results list');

var options = {
  viewpointType: identifi.viewpointType,
  viewpointValue: identifi.viewpointValue,
  maxDistance: identifi.maxDistance,
  limit: identifi.limit || 10,
  offset: identifi.offset || 0
};

identifi.parse(process.argv);

if (!process.argv.slice(2).length) {
  identifi.outputHelp();
  return;
}

// Set user identity placeholder
var myIdType = 'email';
var myIdValue = 'alice@example.com';
var myId = [myIdType, myIdValue];
var myPrivateKey = '-----BEGIN EC PRIVATE KEY-----\n' + 'MHQCAQEEINY+49rac3jkC+S46XN0f411svOveILjev4R3aBehwUKoAcGBSuBBAAK\n' + 'oUQDQgAEKn3lQ3+/aN6xNd9DSFrYbaPSGOzLMbb1kQZ9lCMtwc6Og4hfCMLhaSbE\n' + '3sXek8e2fvKrTp8FY1MyCL4qMeVviA==\n' + '-----END EC PRIVATE KEY-----';
var myKeyId = '12345';

// Process identifier param
var idValue = identifi.args[0];
var idType;
if (identifi.type) {
  idType = identifi.type;
} else if (idValue) {
  idType = identifi_lib.guessTypeOf(idValue) || 'name';
}
if (!idValue) {
  idType = myIdType;
  idValue = myIdValue;
}
var identifier = [idType, idValue];

function showError(error) {
  console.log('Identifi request failed: ');
  if (error.options && error.options.uri && error.options.method) {
      console.log(error.options.method, error.options.uri);
  }
  if (error.response) {
    console.log(error.statusCode, error.response.statusMessage);
  } else {
    if (error.message) {
      console.log(error.message);
    } else {
      console.log(error);
    }
  }
}

function showTypeIfGuessed() {
  if (!identifi.type) {
    console.log(idType + ': ' + idValue);
  }
}

function run() {
  if (identifi.get) {
    return api.request({
      apiMethod: 'id',
      apiIdType: idType,
      apiId: idValue,
      apiAction: 'connections',
      qs: { type: identifi.get }
    }).then(function(res) {
      showTypeIfGuessed();
      console.log('Related ' + identifi.get + ':');
      console.log(res);
    }).catch(showError);
  }

  if (identifi.received) {
    return api.request({
      apiMethod: 'id',
      apiIdType: idType,
      apiId: idValue,
      apiAction: 'received'
    }).then(function(res) {
      showTypeIfGuessed();
      console.log(res);
    }).catch(showError);
  }

  if (identifi.sent) {
    return api.request({
      apiMethod: 'id',
      apiIdType: idType,
      apiId: idValue,
      apiAction: 'sent'
    }).then(function(res) {
      showTypeIfGuessed();
      console.log(res);
    }).catch(showError);
  }

  if (identifi.trustpath) {
    return api.request({
      apiMethod: 'id',
      apiIdType: myIdType,
      apiId: myIdValue,
      apiAction: 'trustpaths',
      qs: { target_type: idType, target_value: idValue }
    }).then(function(res) {
      if (res.length === 0) {
        console.log('No trust path to ' + idType + ':' + idValue + ' found')
      }
      // Format a trustpath string
      for (var i = 0; i < res.length; i++) {
        var tp = res[i];
        if (res[i].path_string) {
          var arr = res[i].path_string.split(':');
          tp = res.length > 1 ? i + ': ' : '';
          for (var j = 0; j < arr.length; j++) {
            if (j % 2 === 1) {
              tp = tp + arr[j-1] + ':' + arr[j];
              if (j < arr.length - 2) {
                tp = tp + ' -> ';
              }
            }
          }
        }
        console.log(tp);
      }
    }).catch(showError);
  }

  if (identifi.rate) {
    if (!parseInt(identifi.rate)) {
      return identifi.outputHelp();
    }
    showTypeIfGuessed();
    var data = {
      author: [myId],
      recipient: [[idType, idValue]],
      rating: identifi.rate
    };
    if (identifi.message) { data['comment'] = identifi.message; }
    var m = message.createRating(data);
    message.sign(m, myPrivateKey, myKeyId);
    return api.request({ method: 'POST', apiMethod: 'messages', body: m }).then(function(res) {
      console.log('Rating saved:');
      console.log(res);
    }).catch(showError);
  }

  if (identifi.connect) {
    showTypeIfGuessed();
    if (identifi.connect.length === 0) {
      return identifi.outputHelp();
    }
    var connectedType = identifi_lib.guessTypeOf(identifi.connect) || 'name';
    var data = {
      author: [myId],
      recipient: [[idType, idValue], [connectedType, identifi.connect]],
      type: 'confirm_connection'
    };
    if (identifi.message) { data['comment'] = identifi.message; }
    var m = message.create(data);
    message.sign(m, myPrivateKey, myKeyId);
    return api.request({ method: 'POST', apiMethod: 'messages', body: m }).then(function(res) {
      console.log('Connection saved:');
      console.log(res);
    }).catch(showError);
  }

  if (identifi.disconnect) {
    showTypeIfGuessed();
    if (identifi.disconnect.length === 0) {
      return identifi.outputHelp();
    }
    var data = {
      author: [myId],
      recipient: [[idType, idValue]],
      type: 'refute_connection'
    };
    if (identifi.message) { data['comment'] = identifi.message; }
    var m = message.create(data);
    message.sign(m, myPrivateKey, myKeyId);
    return api.request({ method: 'POST', apiMethod: 'messages', body: m }).then(function(res) {
      console.log('Disconnection saved:');
      console.log(res);
    }).catch(showError);
  }

  // identity & stats & trustpaths by default
  api.request({ apiMethod: 'id', apiIdType: idType, apiId: idValue })
  .then(function(res) {
    try {
      if (res.length === 0) {
        return console.log('No results for ' + idType + ' ' + idValue);
      }
      for (var i = 0; i < res.length; i++) {
        console.log(res[i].type.gray, res[i].value);
      }
    } catch (err) {
      console.log(res);
    }

    if (res.length) {
      api.request({ apiMethod: 'id', apiIdType: idType, apiId: idValue, apiAction: 'stats' })
      .then(function(res) {
        var s = res[0];
        try {
          console.log('Sent:     ' + (s.sentPositive + ' positive, ').green + (s.sentNeutral + ' neutral, ').yellow + (s.sentNegative + ' negative').red);
          console.log('Received: ' + (s.receivedPositive + ' positive, ').green + (s.receivedNeutral + ' neutral, ').yellow + (s.receivedNegative + ' negative').red);
          console.log('First seen: ' + s.firstSeen);
        } catch (err) {
          console.log(res);
        }
      }).catch(showError);
    }
  }).catch(showError);
}

if (identifi.status) {
  return api.request({ apiMethod: 'status' }).then(function(res) {
    console.log(res);
  }).catch(showError);
};

try {
  run();
} catch (err) {
  console.log(err.message);
}

module.exports = identifi;
